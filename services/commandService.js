// services/commandService.js
const TelegramBot = require('node-telegram-bot-api');
const { exec } = require('child_process');
const config = require('../config/config');
const state = require('./stateService');
const { getStats, getStatus, sendMessageToGroup, searchHistory, getAllWatchedGroups } = require('./whatsappService');
const { getBotPoolStatus, addBotToPool } = require('./telegramService');
const { addTokenToEnv } = require('../utils/envManager');
const locationService = require('./locationService');
const { runHealthCheck } = require('./geminiService');

// 'initialize_full' yerine standart 'initialize' adını kullanıyoruz
function initialize() {
    const token = config.TELEGRAM_TOKENS[0];
    if (!token) { console.error('Komut servisi için Telegram token bulunamadı!'); return; }
    const bot = new TelegramBot(token, { polling: true });

    bot.on('message', async (msg) => {
        const fromId = msg.from.id.toString();
        if (msg.chat.id.toString() !== config.TELEGRAM_LOG_ID || !state.getAdmins().includes(fromId)) return;
        
        const text = msg.text || '';
        if (!text.startsWith('/')) return;
        
        const args = text.slice(1).trim().split(/ +/g);
        const command = args.shift().toLowerCase();
        const reply = (message) => bot.sendMessage(msg.chat.id, message, { parse_mode: 'HTML' });
        const getTargetId = () => { if (msg.reply_to_message) return msg.reply_to_message.from.id.toString(); if (args[0] && /^\d+$/.test(args[0])) return args[0]; return null; };

        switch (command) {
            case 'status': { const waStatus = getStatus(); const uptime = (process.uptime() / 3600).toFixed(2); reply(`✅ <b>Bot Durumu</b>\n\n- <b>WhatsApp Bağlantısı:</b> ${waStatus.isConnected ? '🟢 Bağlı' : '🔴 Bağlı Değil'}\n- <b>Çalışma Süresi:</b> ${uptime} saat`); break; }
            case 'stats': { const stats = getStats(); reply(`📊 <b>İstatistikler</b>\n\n- <b>İşlenen Mesaj Sayısı:</b> ${stats.processedMessages}`); break; }
            case 'config': { const blocked = state.getBlockedGroups().join(', ') || 'Yok'; const watched = config.WATCHED_GROUPS.join(', ') || 'Tümü İzleniyor'; const keywords = state.getKoliKeywords().join(', ') || 'Yok'; reply(`⚙️ <b>Mevcut Ayarlar</b>\n\n- <b>Engellenen Gruplar:</b> ${blocked}\n- <b>İzlenen Gruplar:</b> ${watched}\n- <b>Koli Anahtar Kelimeleri:</b> ${keywords}`); break; }
            case 'block': { const groupNameToBlock = args.join(' '); if (!groupNameToBlock) return reply('Kullanım: /block <Grup Adı>'); if (state.addBlockedGroup(groupNameToBlock)) { reply(`✅ "<b>${groupNameToBlock}</b>" adlı grup kalıcı olarak engellendi.`); } else { reply(`ℹ️ "<b>${groupNameToBlock}</b>" adlı grup zaten engelli.`); } break; }
            case 'unblock': { const groupNameToUnblock = args.join(' '); if (!groupNameToUnblock) return reply('Kullanım: /unblock <Grup Adı>'); if (state.removeBlockedGroup(groupNameToUnblock)) { reply(`✅ "<b>${groupNameToUnblock}</b>" adlı grubun engeli kalıcı olarak kaldırıldı.`); } else { reply(`ℹ️ "<b>${groupNameToUnblock}</b>" adlı grup engelli değil.`); } break; }
            case 'addadmin': { const targetId = getTargetId(); if (!targetId) return reply('Kullanım: Bir kullanıcının mesajını yanıtlayın veya /addadmin <Kullanıcı ID>'); if (state.addAdmin(targetId)) { reply(`✅ <b>${targetId}</b> ID'li kullanıcı yönetici olarak eklendi.`); } else { reply(`ℹ️ <b>${targetId}</b> ID'li kullanıcı zaten bir yönetici.`); } break; }
            case 'removeadmin': { const targetId = getTargetId(); if (!targetId) return reply('Kullanım: Bir kullanıcının mesajını yanıtlayın veya /removeadmin <Kullanıcı ID>'); const result = state.removeAdmin(targetId); if (result === 'success') { reply(`✅ <b>${targetId}</b> ID'li kullanıcının yöneticiliği kaldırıldı.`); } else if (result === 'primary') { reply(`❌ Ana yönetici (.env dosyasından gelen) silinemez.`); } else if (result === 'last') { reply(`❌ Son yönetici silinemez. Sistemde en az bir yönetici kalmalıdır.`); } else if (result === 'not_found') { reply(`ℹ️ <b>${targetId}</b> ID'li kullanıcı yönetici değil.`); } break; }
            case 'listadmins': { const adminList = state.getAdmins(); const primaryAdmin = config.ADMIN_TELEGRAM_ID.toString(); const message = adminList.map(id => `- <code>${id}</code> ${id === primaryAdmin ? '(Ana Admin)' : ''}`).join('\n'); reply(`👑 <b>Yönetici Listesi:</b>\n\n${message}`); break; }
            case 'addkeyword': { const keywordToAdd = args.join(' '); if (!keywordToAdd) return reply('Kullanım: /addkeyword <anahtar_kelime>'); if (state.addKoliKeyword(keywordToAdd)) { reply(`✅ "<b>${keywordToAdd}</b>" anahtar kelimesi eklendi.`); } else { reply(`ℹ️ "<b>${keywordToAdd}</b>" zaten listede mevcut.`); } break; }
            case 'removekeyword': { const keywordToRemove = args.join(' '); if (!keywordToRemove) return reply('Kullanım: /removekeyword <anahtar_kelime>'); if (state.removeKoliKeyword(keywordToRemove)) { reply(`✅ "<b>${keywordToRemove}</b>" anahtar kelimesi silindi.`); } else { reply(`ℹ️ "<b>${keywordToRemove}</b>" listede bulunamadı.`); } break; }
            case 'listkeywords': { const keywordList = state.getKoliKeywords(); if (keywordList.length === 0) return reply('📦 Tanımlı koli anahtar kelimesi bulunmuyor.'); const message = keywordList.map(kw => `- <code>${kw}</code>`).join('\n'); reply(`📦 <b>Koli Anahtar Kelimeleri:</b>\n\n${message}`); break; }
            case 'botstatus': { const botPool = getBotPoolStatus(); let message = "🤖 <b>Telegram Bot Havuzu Durumu</b> 🤖\n\n"; botPool.forEach(bot => { message += `- <b>Bot ID ${bot.id}:</b> ${bot.active ? '🟢 Aktif' : '🔴 Pasif'}\n`; if (!bot.active) { message += `  - <i>Hata Sayısı: ${bot.failures}</i>\n`; message += `  - <i>Son Hata: ${new Date(bot.lastFailureTime).toLocaleString('tr-TR')}</i>\n`; } }); const activeBotCount = botPool.filter(b => b.active).length; message += `\nToplam <b>${botPool.length}</b> bottan <b>${activeBotCount}</b> tanesi aktif.`; reply(message); break; }
            case 'addtoken': { const newToken = args[0]; if (!newToken || !newToken.includes(':')) { return reply('Kullanım: /addtoken <yeni_bot_tokeni>'); } await reply(`⏳ Yeni token .env dosyasına ekleniyor ve canlıya alınıyor...`); const result = addTokenToEnv(newToken); if (!result.success) { return reply(`❌ Token .env dosyasına eklenirken bir hata oluştu: <pre>${result.error}</pre>`); } const addedToPool = addBotToPool(newToken); if (!addedToPool) { return reply(`⚠️ Token .env dosyasına <b>${result.newTokenKey}</b> olarak eklendi ancak canlı havuza eklenemedi (muhtemelen zaten mevcuttu).`); } return reply(`✅ Başarılı!\n\n- Token, <b>${result.newTokenKey}</b> olarak .env dosyasına kalıcı bir şekilde eklendi.\n- Yeni bot canlı olarak havuza dahil edildi.`); break; }
            case 'geminitest': { await reply('🧠 Gemini API sağlık durumu kontrol ediliyor...'); const result = await runHealthCheck(); if (result.success) { return reply(`✅ <b>Başarılı!</b>\n\nGemini API entegrasyonu sorunsuz çalışıyor.\nAPI'dan gelen cevap: <code>${result.response}</code>`); } else { return reply(`❌ <b>Hata!</b>\n\nGemini API'a bağlanılamadı.\n<b>Detay:</b> <pre>${result.error}</pre>`); } break; }
            case 'start': case 'restart': case 'shutdown': { const pm2Name = args[0]; if (!pm2Name) return reply(`Kullanım: /${command} <pm2_süreç_adı>`); const pm2Command = command === 'shutdown' ? 'stop' : command; reply(`⏳ PM2 süreci "<b>${pm2Name}</b>" için <b>${pm2Command}</b> komutu gönderiliyor...`); exec(`pm2 ${pm2Command} ${pm2Name}`, (error, stdout, stderr) => { if (error) return reply(`❌ <b>Hata:</b>\n<pre>${error.message}</pre>`); if (stderr) return reply(`⚠️ <b>Uyarı:</b>\n<pre>${stderr}</pre>`); reply(`✅ "<b>${pm2Name}</b>" süreci için <b>${pm2Command}</b> komutu başarıyla çalıştırıldı.\n\n<pre>${stdout}</pre>`); }); break; }
            case 'rota': { const startCity = args[0]; const endCity = args[1]; if (!startCity || !endCity) { return reply('Kullanım: /rota <kalkış_şehri> <varış_şehri>'); } const startCoords = locationService.getLocationCoords(startCity); const endCoords = locationService.getLocationCoords(endCity); if (!startCoords || !endCoords) { return reply(`❌ Belirtilen şehirler bulunamadı. Lütfen isimleri kontrol et: ${!startCoords ? `<b>${startCity}</b>` : ''} ${!endCoords ? `<b>${endCity}</b>` : ''}`); } await reply(`⏳ Rota hesaplanıyor: <b>${startCity} -> ${endCity}</b>...`); let citiesOnRoute = state.getRouteFromCache(startCity, endCity); if (citiesOnRoute) { console.log(`Rota '${startCity}-${endCity}' için önbellekten yüklendi.`); } else { console.log(`Rota '${startCity}-${endCity}' için hesaplama yapılıyor...`); const allLocations = locationService.getAllLocations(); citiesOnRoute = allLocations.filter(loc => locationService.isLocationOnRoute(loc, startCoords, endCoords)).map(loc => loc.name); state.saveRouteToCache(startCity, endCity, citiesOnRoute); } state.setActiveRoute(startCity, endCity, citiesOnRoute); return reply(`✅ Rota aktif: <b>${startCity} -> ${endCity}</b>\nBu rota üzerindeki <b>${citiesOnRoute.length}</b> il/ilçe için iş takibi başlatıldı.`); break; }
            case 'rotadurum': { const currentRoute = state.getActiveRoute(); if (currentRoute) { return reply(`ℹ️ Aktif Rota: <b>${currentRoute.start} -> ${currentRoute.end}</b>\nİzlenen il/ilçe sayısı: <b>${currentRoute.cities.length}</b>`); } else { return reply('ℹ️ Şu anda aktif bir rota bulunmuyor.'); } break; }
            case 'rotasil': { state.clearActiveRoute(); return reply('✅ Aktif rota temizlendi. Rota takibi durduruldu.'); break; }
            case 'duyuru': { const targetGroupRaw = args.shift(); const messageToSend = args.join(' '); if (!targetGroupRaw || !messageToSend) { return reply('Kullanım: /duyuru <grup_adı> <mesaj>\n(Tüm izlenen gruplar için: /duyuru hepsi <mesaj>)'); } await reply(`⏳ Duyuru(lar) gönderiliyor...`); let targets = []; if (targetGroupRaw.toLowerCase() === 'hepsi') { targets = await getAllWatchedGroups(); if (targets.length === 0) { return reply('İzlenen grup (`WATCHED_GROUPS`) listesi .env dosyasında boş.'); } } else { targets.push(targetGroupRaw); } let s=0, e=0, errs=''; for (const group of targets) { const result = await sendMessageToGroup(group, messageToSend); if (result.success) { s++; } else { e++; errs += `- ${group}: ${result.error}\n`; } } let report = `📢 <b>Duyuru Raporu</b>\n\n- Başarılı: <b>${s}</b>\n- Hatalı: <b>${e}</b>`; if (e > 0) { report += `\n\n<b>Hatalar:</b>\n<pre>${errs}</pre>`; } return reply(report); break; }
            case 'analiz': { const subCommand = args[0]; if (subCommand === 'grup') { const { groupStats } = getStats(); const sortedGroups = Object.entries(groupStats).sort(([, a], [, b]) => b - a).slice(0, 10); if (sortedGroups.length === 0) { return reply('📈 Henüz analiz edilecek grup verisi bulunmuyor.'); } let message = '📈 <b>En Aktif 10 Grup</b>\n\n'; sortedGroups.forEach(([groupName, count], index) => { message += `<b>${index + 1}.</b> ${groupName} - <i>(${count} mesaj)</i>\n`; }); return reply(message); } else { return reply('Kullanım: /analiz grup'); } break; }
            case 'ara': { const query = args.join(' '); if (!query || query.length < 3) return reply('Kullanım: /ara <en_az_3_harfli_kelime>'); const results = searchHistory(query); if (results.length === 0) { return reply(`🔎 "<b>${query}</b>" için son 200 mesaj içinde sonuç bulunamadı.`); } let message = `🔎 "<b>${query}</b>" için bulunan sonuçlar (${results.length} adet):\n\n`; results.slice(0, 5).forEach(msg => { const time = msg.timestamp.toLocaleTimeString('tr-TR'); message += `➖➖➖➖➖➖\n<b>Grup:</b> ${msg.groupName} (${time})\n<b>Mesaj:</b>\n<i>${msg.body.slice(0, 200)}...</i>\n`; }); if (results.length > 5) { message += `\n...ve ${results.length - 5} sonuç daha bulundu.` } return reply(message); break; }
        }
    });
    console.log('Komut dinleme servisi başlatıldı.');
}

module.exports = { initialize }; // DÜZELTİLDİ: Fonksiyonu doğru şekilde export ediyoruz.