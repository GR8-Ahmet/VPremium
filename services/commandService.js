// services/commandService.js
const TelegramBot = require('node-telegram-bot-api');
const { exec } = require('child_process');
const config = require('../config/config');
const state = require('./stateService');
const { getStats, getStatus, sendMessageToGroup, searchHistory, getAllWatchedGroups } = require('./whatsappService');
const { getBotPoolStatus, addBotToPool } = require('./telegramService');
const { addTokenToEnv } = require('../utils/envManager');
const locationService = require('./locationService');
const { runHealthCheck } = require('./geminiService');

// 'initialize_full' yerine standart 'initialize' adÄ±nÄ± kullanÄ±yoruz
function initialize() {
    const token = config.TELEGRAM_TOKENS[0];
    if (!token) { console.error('Komut servisi iÃ§in Telegram token bulunamadÄ±!'); return; }
    const bot = new TelegramBot(token, { polling: true });

    bot.on('message', async (msg) => {
        const fromId = msg.from.id.toString();
        if (msg.chat.id.toString() !== config.TELEGRAM_LOG_ID || !state.getAdmins().includes(fromId)) return;
        
        const text = msg.text || '';
        if (!text.startsWith('/')) return;
        
        const args = text.slice(1).trim().split(/ +/g);
        const command = args.shift().toLowerCase();
        const reply = (message) => bot.sendMessage(msg.chat.id, message, { parse_mode: 'HTML' });
        const getTargetId = () => { if (msg.reply_to_message) return msg.reply_to_message.from.id.toString(); if (args[0] && /^\d+$/.test(args[0])) return args[0]; return null; };

        switch (command) {
            case 'status': { const waStatus = getStatus(); const uptime = (process.uptime() / 3600).toFixed(2); reply(`âœ… <b>Bot Durumu</b>\n\n- <b>WhatsApp BaÄŸlantÄ±sÄ±:</b> ${waStatus.isConnected ? 'ğŸŸ¢ BaÄŸlÄ±' : 'ğŸ”´ BaÄŸlÄ± DeÄŸil'}\n- <b>Ã‡alÄ±ÅŸma SÃ¼resi:</b> ${uptime} saat`); break; }
            case 'stats': { const stats = getStats(); reply(`ğŸ“Š <b>Ä°statistikler</b>\n\n- <b>Ä°ÅŸlenen Mesaj SayÄ±sÄ±:</b> ${stats.processedMessages}`); break; }
            case 'config': { const blocked = state.getBlockedGroups().join(', ') || 'Yok'; const watched = config.WATCHED_GROUPS.join(', ') || 'TÃ¼mÃ¼ Ä°zleniyor'; const keywords = state.getKoliKeywords().join(', ') || 'Yok'; reply(`âš™ï¸ <b>Mevcut Ayarlar</b>\n\n- <b>Engellenen Gruplar:</b> ${blocked}\n- <b>Ä°zlenen Gruplar:</b> ${watched}\n- <b>Koli Anahtar Kelimeleri:</b> ${keywords}`); break; }
            case 'block': { const groupNameToBlock = args.join(' '); if (!groupNameToBlock) return reply('KullanÄ±m: /block <Grup AdÄ±>'); if (state.addBlockedGroup(groupNameToBlock)) { reply(`âœ… "<b>${groupNameToBlock}</b>" adlÄ± grup kalÄ±cÄ± olarak engellendi.`); } else { reply(`â„¹ï¸ "<b>${groupNameToBlock}</b>" adlÄ± grup zaten engelli.`); } break; }
            case 'unblock': { const groupNameToUnblock = args.join(' '); if (!groupNameToUnblock) return reply('KullanÄ±m: /unblock <Grup AdÄ±>'); if (state.removeBlockedGroup(groupNameToUnblock)) { reply(`âœ… "<b>${groupNameToUnblock}</b>" adlÄ± grubun engeli kalÄ±cÄ± olarak kaldÄ±rÄ±ldÄ±.`); } else { reply(`â„¹ï¸ "<b>${groupNameToUnblock}</b>" adlÄ± grup engelli deÄŸil.`); } break; }
            case 'addadmin': { const targetId = getTargetId(); if (!targetId) return reply('KullanÄ±m: Bir kullanÄ±cÄ±nÄ±n mesajÄ±nÄ± yanÄ±tlayÄ±n veya /addadmin <KullanÄ±cÄ± ID>'); if (state.addAdmin(targetId)) { reply(`âœ… <b>${targetId}</b> ID'li kullanÄ±cÄ± yÃ¶netici olarak eklendi.`); } else { reply(`â„¹ï¸ <b>${targetId}</b> ID'li kullanÄ±cÄ± zaten bir yÃ¶netici.`); } break; }
            case 'removeadmin': { const targetId = getTargetId(); if (!targetId) return reply('KullanÄ±m: Bir kullanÄ±cÄ±nÄ±n mesajÄ±nÄ± yanÄ±tlayÄ±n veya /removeadmin <KullanÄ±cÄ± ID>'); const result = state.removeAdmin(targetId); if (result === 'success') { reply(`âœ… <b>${targetId}</b> ID'li kullanÄ±cÄ±nÄ±n yÃ¶neticiliÄŸi kaldÄ±rÄ±ldÄ±.`); } else if (result === 'primary') { reply(`âŒ Ana yÃ¶netici (.env dosyasÄ±ndan gelen) silinemez.`); } else if (result === 'last') { reply(`âŒ Son yÃ¶netici silinemez. Sistemde en az bir yÃ¶netici kalmalÄ±dÄ±r.`); } else if (result === 'not_found') { reply(`â„¹ï¸ <b>${targetId}</b> ID'li kullanÄ±cÄ± yÃ¶netici deÄŸil.`); } break; }
            case 'listadmins': { const adminList = state.getAdmins(); const primaryAdmin = config.ADMIN_TELEGRAM_ID.toString(); const message = adminList.map(id => `- <code>${id}</code> ${id === primaryAdmin ? '(Ana Admin)' : ''}`).join('\n'); reply(`ğŸ‘‘ <b>YÃ¶netici Listesi:</b>\n\n${message}`); break; }
            case 'addkeyword': { const keywordToAdd = args.join(' '); if (!keywordToAdd) return reply('KullanÄ±m: /addkeyword <anahtar_kelime>'); if (state.addKoliKeyword(keywordToAdd)) { reply(`âœ… "<b>${keywordToAdd}</b>" anahtar kelimesi eklendi.`); } else { reply(`â„¹ï¸ "<b>${keywordToAdd}</b>" zaten listede mevcut.`); } break; }
            case 'removekeyword': { const keywordToRemove = args.join(' '); if (!keywordToRemove) return reply('KullanÄ±m: /removekeyword <anahtar_kelime>'); if (state.removeKoliKeyword(keywordToRemove)) { reply(`âœ… "<b>${keywordToRemove}</b>" anahtar kelimesi silindi.`); } else { reply(`â„¹ï¸ "<b>${keywordToRemove}</b>" listede bulunamadÄ±.`); } break; }
            case 'listkeywords': { const keywordList = state.getKoliKeywords(); if (keywordList.length === 0) return reply('ğŸ“¦ TanÄ±mlÄ± koli anahtar kelimesi bulunmuyor.'); const message = keywordList.map(kw => `- <code>${kw}</code>`).join('\n'); reply(`ğŸ“¦ <b>Koli Anahtar Kelimeleri:</b>\n\n${message}`); break; }
            case 'botstatus': { const botPool = getBotPoolStatus(); let message = "ğŸ¤– <b>Telegram Bot Havuzu Durumu</b> ğŸ¤–\n\n"; botPool.forEach(bot => { message += `- <b>Bot ID ${bot.id}:</b> ${bot.active ? 'ğŸŸ¢ Aktif' : 'ğŸ”´ Pasif'}\n`; if (!bot.active) { message += `  - <i>Hata SayÄ±sÄ±: ${bot.failures}</i>\n`; message += `  - <i>Son Hata: ${new Date(bot.lastFailureTime).toLocaleString('tr-TR')}</i>\n`; } }); const activeBotCount = botPool.filter(b => b.active).length; message += `\nToplam <b>${botPool.length}</b> bottan <b>${activeBotCount}</b> tanesi aktif.`; reply(message); break; }
            case 'addtoken': { const newToken = args[0]; if (!newToken || !newToken.includes(':')) { return reply('KullanÄ±m: /addtoken <yeni_bot_tokeni>'); } await reply(`â³ Yeni token .env dosyasÄ±na ekleniyor ve canlÄ±ya alÄ±nÄ±yor...`); const result = addTokenToEnv(newToken); if (!result.success) { return reply(`âŒ Token .env dosyasÄ±na eklenirken bir hata oluÅŸtu: <pre>${result.error}</pre>`); } const addedToPool = addBotToPool(newToken); if (!addedToPool) { return reply(`âš ï¸ Token .env dosyasÄ±na <b>${result.newTokenKey}</b> olarak eklendi ancak canlÄ± havuza eklenemedi (muhtemelen zaten mevcuttu).`); } return reply(`âœ… BaÅŸarÄ±lÄ±!\n\n- Token, <b>${result.newTokenKey}</b> olarak .env dosyasÄ±na kalÄ±cÄ± bir ÅŸekilde eklendi.\n- Yeni bot canlÄ± olarak havuza dahil edildi.`); break; }
            case 'geminitest': { await reply('ğŸ§  Gemini API saÄŸlÄ±k durumu kontrol ediliyor...'); const result = await runHealthCheck(); if (result.success) { return reply(`âœ… <b>BaÅŸarÄ±lÄ±!</b>\n\nGemini API entegrasyonu sorunsuz Ã§alÄ±ÅŸÄ±yor.\nAPI'dan gelen cevap: <code>${result.response}</code>`); } else { return reply(`âŒ <b>Hata!</b>\n\nGemini API'a baÄŸlanÄ±lamadÄ±.\n<b>Detay:</b> <pre>${result.error}</pre>`); } break; }
            case 'start': case 'restart': case 'shutdown': { const pm2Name = args[0]; if (!pm2Name) return reply(`KullanÄ±m: /${command} <pm2_sÃ¼reÃ§_adÄ±>`); const pm2Command = command === 'shutdown' ? 'stop' : command; reply(`â³ PM2 sÃ¼reci "<b>${pm2Name}</b>" iÃ§in <b>${pm2Command}</b> komutu gÃ¶nderiliyor...`); exec(`pm2 ${pm2Command} ${pm2Name}`, (error, stdout, stderr) => { if (error) return reply(`âŒ <b>Hata:</b>\n<pre>${error.message}</pre>`); if (stderr) return reply(`âš ï¸ <b>UyarÄ±:</b>\n<pre>${stderr}</pre>`); reply(`âœ… "<b>${pm2Name}</b>" sÃ¼reci iÃ§in <b>${pm2Command}</b> komutu baÅŸarÄ±yla Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±.\n\n<pre>${stdout}</pre>`); }); break; }
            case 'rota': { const startCity = args[0]; const endCity = args[1]; if (!startCity || !endCity) { return reply('KullanÄ±m: /rota <kalkÄ±ÅŸ_ÅŸehri> <varÄ±ÅŸ_ÅŸehri>'); } const startCoords = locationService.getLocationCoords(startCity); const endCoords = locationService.getLocationCoords(endCity); if (!startCoords || !endCoords) { return reply(`âŒ Belirtilen ÅŸehirler bulunamadÄ±. LÃ¼tfen isimleri kontrol et: ${!startCoords ? `<b>${startCity}</b>` : ''} ${!endCoords ? `<b>${endCity}</b>` : ''}`); } await reply(`â³ Rota hesaplanÄ±yor: <b>${startCity} -> ${endCity}</b>...`); let citiesOnRoute = state.getRouteFromCache(startCity, endCity); if (citiesOnRoute) { console.log(`Rota '${startCity}-${endCity}' iÃ§in Ã¶nbellekten yÃ¼klendi.`); } else { console.log(`Rota '${startCity}-${endCity}' iÃ§in hesaplama yapÄ±lÄ±yor...`); const allLocations = locationService.getAllLocations(); citiesOnRoute = allLocations.filter(loc => locationService.isLocationOnRoute(loc, startCoords, endCoords)).map(loc => loc.name); state.saveRouteToCache(startCity, endCity, citiesOnRoute); } state.setActiveRoute(startCity, endCity, citiesOnRoute); return reply(`âœ… Rota aktif: <b>${startCity} -> ${endCity}</b>\nBu rota Ã¼zerindeki <b>${citiesOnRoute.length}</b> il/ilÃ§e iÃ§in iÅŸ takibi baÅŸlatÄ±ldÄ±.`); break; }
            case 'rotadurum': { const currentRoute = state.getActiveRoute(); if (currentRoute) { return reply(`â„¹ï¸ Aktif Rota: <b>${currentRoute.start} -> ${currentRoute.end}</b>\nÄ°zlenen il/ilÃ§e sayÄ±sÄ±: <b>${currentRoute.cities.length}</b>`); } else { return reply('â„¹ï¸ Åu anda aktif bir rota bulunmuyor.'); } break; }
            case 'rotasil': { state.clearActiveRoute(); return reply('âœ… Aktif rota temizlendi. Rota takibi durduruldu.'); break; }
            case 'duyuru': { const targetGroupRaw = args.shift(); const messageToSend = args.join(' '); if (!targetGroupRaw || !messageToSend) { return reply('KullanÄ±m: /duyuru <grup_adÄ±> <mesaj>\n(TÃ¼m izlenen gruplar iÃ§in: /duyuru hepsi <mesaj>)'); } await reply(`â³ Duyuru(lar) gÃ¶nderiliyor...`); let targets = []; if (targetGroupRaw.toLowerCase() === 'hepsi') { targets = await getAllWatchedGroups(); if (targets.length === 0) { return reply('Ä°zlenen grup (`WATCHED_GROUPS`) listesi .env dosyasÄ±nda boÅŸ.'); } } else { targets.push(targetGroupRaw); } let s=0, e=0, errs=''; for (const group of targets) { const result = await sendMessageToGroup(group, messageToSend); if (result.success) { s++; } else { e++; errs += `- ${group}: ${result.error}\n`; } } let report = `ğŸ“¢ <b>Duyuru Raporu</b>\n\n- BaÅŸarÄ±lÄ±: <b>${s}</b>\n- HatalÄ±: <b>${e}</b>`; if (e > 0) { report += `\n\n<b>Hatalar:</b>\n<pre>${errs}</pre>`; } return reply(report); break; }
            case 'analiz': { const subCommand = args[0]; if (subCommand === 'grup') { const { groupStats } = getStats(); const sortedGroups = Object.entries(groupStats).sort(([, a], [, b]) => b - a).slice(0, 10); if (sortedGroups.length === 0) { return reply('ğŸ“ˆ HenÃ¼z analiz edilecek grup verisi bulunmuyor.'); } let message = 'ğŸ“ˆ <b>En Aktif 10 Grup</b>\n\n'; sortedGroups.forEach(([groupName, count], index) => { message += `<b>${index + 1}.</b> ${groupName} - <i>(${count} mesaj)</i>\n`; }); return reply(message); } else { return reply('KullanÄ±m: /analiz grup'); } break; }
            case 'ara': { const query = args.join(' '); if (!query || query.length < 3) return reply('KullanÄ±m: /ara <en_az_3_harfli_kelime>'); const results = searchHistory(query); if (results.length === 0) { return reply(`ğŸ” "<b>${query}</b>" iÃ§in son 200 mesaj iÃ§inde sonuÃ§ bulunamadÄ±.`); } let message = `ğŸ” "<b>${query}</b>" iÃ§in bulunan sonuÃ§lar (${results.length} adet):\n\n`; results.slice(0, 5).forEach(msg => { const time = msg.timestamp.toLocaleTimeString('tr-TR'); message += `â–â–â–â–â–â–\n<b>Grup:</b> ${msg.groupName} (${time})\n<b>Mesaj:</b>\n<i>${msg.body.slice(0, 200)}...</i>\n`; }); if (results.length > 5) { message += `\n...ve ${results.length - 5} sonuÃ§ daha bulundu.` } return reply(message); break; }
        }
    });
    console.log('Komut dinleme servisi baÅŸlatÄ±ldÄ±.');
}

module.exports = { initialize }; // DÃœZELTÄ°LDÄ°: Fonksiyonu doÄŸru ÅŸekilde export ediyoruz.